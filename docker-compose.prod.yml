version: '3.8'

services:
  nestjs_api_prod:
    build:
      context: .
      dockerfile: Dockerfile.prod
    ports:
      - '3001:3001'
    environment:
      - PORT=${PORT}
      - NODE_ENV=production
      - DATABASE_USERNAME=${DATABASE_USERNAME}
      - DATABASE_PASSWORD=${DATABASE_PASSWORD}
      - DATABASE_NAME=${DATABASE_NAME}
      - ACCESS_TOKEN=${ACCESS_TOKEN}
      - REFRESH_TOKEN=${REFRESH_TOKEN}
      - ROLE_TOKEN=${ROLE_TOKEN}
# version: '3.8'

# services:
#   app:
#     build:
#       context: .  # Assuming the Dockerfile is in the current directory
#       dockerfile: Dockerfile.prod  # Specify your production Dockerfile
#     environment:
#       # Database credentials
#       - DATABASE_HOST=db  # Use the service name for inter-container communication
#       - DATABASE_USERNAME=${DATABASE_USERNAME}
#       - DATABASE_PASSWORD=${DATABASE_PASSWORD}
#       - DATABASE_NAME=${DATABASE_NAME}
#       - DATABASE_PORT=5432  # Default PostgreSQL port

#     ports:
#       - '3001:3001'  # Expose the app on port 3001
#     depends_on:
#       - db  # Ensure the database starts before the app
#     restart: unless-stopped  # Automatically restart the container if it fails

#   db:
#     image: postgres:13  # Use the official PostgreSQL image
#     environment:
#       - POSTGRES_USER=${DATABASE_USERNAME}
#       - POSTGRES_PASSWORD=${DATABASE_PASSWORD}
#       - POSTGRES_DB=${DATABASE_NAME}
#     volumes:
#       - db_data:/var/lib/postgresql/data  # Persist database data
#     ports:
#       - '5432:5432'  # Expose PostgreSQL on port 5432
#     restart: unless-stopped  # Restart if the container fails

# volumes:
#   db_data:
#     driver: local  # Use local storage for database data
